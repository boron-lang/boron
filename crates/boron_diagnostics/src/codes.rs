use crate::DiagnosticCode;

// NOTE: Codes are global (0001..9999). Do NOT reuse or renumber existing codes.
// If you change meaning, add a new code.

macro_rules! define_codes {
  ($($name:ident => $value:literal),+ $(,)?) => {
    $(
      pub const $name: DiagnosticCode = DiagnosticCode::new($value);
    )+

    pub const ALL_CODES: &[DiagnosticCode] = &[
      $( $name, )+
    ];
  };
}

define_codes! {
  // Lexer (0001..0099)
  LEX_UNTERMINATED_STRING => 1,
  LEX_UNTERMINATED_CHAR => 2,
  LEX_UNTERMINATED_BLOCK_COMMENT => 3,
  LEX_INVALID_ESCAPE => 4,
  LEX_INVALID_BYTE_VALUE => 5,
  LEX_EMPTY_CHAR_LITERAL => 6,
  LEX_MULTI_CHAR_LITERAL => 7,
  LEX_MISSING_DIGITS_AFTER_BASE => 8,
  LEX_INVALID_DIGIT_FOR_BASE => 9,
  LEX_MALFORMED_EXPONENT => 10,
  LEX_INVALID_UTF8 => 11,
  LEX_UNEXPECTED_BOM => 12,
  LEX_DISALLOWED_CODE_POINT => 13,
  LEX_NON_ASCII_WHITESPACE => 14,
  LEX_INVALID_IDENTIFIER_START => 15,
  LEX_INVALID_IDENTIFIER_CONTINUE => 16,
  LEX_JOIN_CONTROL_IN_IDENTIFIER => 17,
  LEX_UNATTACHED_DOC_COMMENT => 18,
  LEX_UNEXPECTED_CHARACTER => 19,
  LEX_TOO_MANY_CHARS_IN_BYTE_LITERAL => 20,

  // Parser (0100..0199)
  PARSE_UNEXPECTED_TOKEN => 100,
  PARSE_MOD_STRING_LIT => 101,
  PARSE_MOD_EXPECTED_IDENTIFIER => 102,
  PARSE_CONST_ALONE_IN_A_TYPE => 103,
  PARSE_CONST_EXPECTED_FUNC_OR_IDENT => 104,
  PARSE_CONST_NEED_TYPE_ANNOTATIONS => 105,
  PARSE_CONST_CANNOT_BE_UNINITIALIZED => 106,
  PARSE_EXPECTED_TYPE => 107,
  PARSE_PACKAGE_ROOT_ONLY => 108,
  PARSE_EXPECTED_SUPER_OR_IDENT_PATH => 109,
  PARSE_FUNCTION_CAMEL_CASE => 110,
  PARSE_EXPECTED_IDENTIFIER_IN_GENERIC => 111,
  PARSE_EXPECTED_TYPE_PATH_FOR_BOUND => 112,
  PARSE_TRAILING_PLUS_IN_TYPE_BOUND => 113,
  PARSE_EXPECTED_IDENT_OR_DOTS => 114,
  PARSE_VARIADIC_NO_DEFAULT => 115,
  PARSE_ALL_VARS_INIT => 116,
  PARSE_EXPECTED_EXPR => 117,
  PARSE_EXPECTED_EXPR_FOUND => 118,
  PARSE_BREAK_OUTSIDE_LOOP => 119,
  PARSE_CONTINUE_OUTSIDE_LOOP => 120,
  PARSE_EXPECTED_FAT_ARROW => 121,
  PARSE_EXPECTED_PATTERN => 122,
  PARSE_EXPECTED_BUILTIN_NAME => 123,
  PARSE_INVALID_ASSIGN_TARGET => 124,
  PARSE_EXPECTED_FIELD_NAME => 125,
  PARSE_MISSING_COLON_IN_TERNARY => 126,
  PARSE_MISSING_IN_KEYWORD => 127,
  PARSE_UNCLOSED_DELIMITER => 128,
  PARSE_EMPTY_MATCH => 129,
  PARSE_DUPLICATE_NAMED_ARG => 130,
  PARSE_MISSING_OPERAND => 131,
  PARSE_EXPECTED_FIELD_VALUE => 132,
  PARSE_MODULE_NOT_FOUND => 133,
  PARSE_EXPECTED_IDENTIFIER_IN_NORMAL_PATH => 134,
  PARSE_GENERICS_IN_IMPORT_OR_MOD => 135,
  PARSE_ALIASING_A_BINDING => 136,
  PARSE_UNEXPECTED_IMPORT_KIND => 137,
  PARSE_IMPORT_NOT_A_PATH => 138,
  PARSE_EXPECTED_PAREN_OPEN_LIST => 139,
  PARSE_REPEAT_SYNTAX_ONLY_AT_START => 140,
  PARSE_INVALID_REPEAT_SYNTAX => 141,
  PARSE_REPEAT_SYNTAX_REQUIRED_VALUE => 142,
  PARSE_SUPER_ONLY_IN_MOD_OR_IMPORT => 143,
  PARSE_INVALID_FIELD_INIT => 144,
  PARSE_USE_VAR_NOT_CONST => 145,
  PARSE_INVALID_FIELD_PATTERN => 146,
  PARSE_ABI_MUST_BE_EXPLICIT => 147,
  PARSE_COMPTIME_EXTERN_TOGETHER => 148,
  PARSE_POSITIONAL_AFTER_NAMED => 149,
  PARSE_INVALID_VARIANT => 150,

  // Resolver (0200..0299)
  RESOLVE_UNDEFINED_NAME => 200,
  RESOLVE_UNDEFINED_TYPE => 201,
  RESOLVE_DUPLICATE_DEFINITION => 202,
  RESOLVE_UNDEFINED_MODULE => 203,
  RESOLVE_CYCLIC_IMPORT => 204,
  RESOLVE_PRIVATE_ITEM => 205,
  RESOLVE_UNRESOLVED_IMPORT => 206,
  RESOLVE_INVALID_PATH_ROOT => 207,
  RESOLVE_UNDEFINED_NAME_IN_MODULE => 208,
  RESOLVE_NO_METHOD_FOUND => 209,
  RESOLVE_SELF_OUTSIDE_METHOD => 210,

  // Comptime (0300..0399)
  COMPTIME_NO_GENERICS => 301,
  COMPTIME_FAILED_TO_CONSTRUCT_INT_LIT => 302,
  COMPTIME_FAILED_TO_CONSTRUCT_FLOAT_LIT => 303,

  // Type checker (0400..0499)
  TYPE_CHECKER_ARRAY_LENGTH_NOT_A_NUMBER => 400,
  TYPE_CHECKER_VAR_INIT_MISMATCH => 401,
  TYPE_CHECKER_NOT_AN_INTEGER => 402,
  TYPE_CHECKER_NOT_A_FLOAT => 403,
  TYPE_CHECKER_OCCURS_CHECK => 404,
  TYPE_CHECKER_ARRAY_LEN_MISMATCH => 405,
  TYPE_CHECKER_INVALID_STRUCT_INIT => 406,
  TYPE_CHECKER_NO_FIELD => 407,
  TYPE_CHECKER_FIELD_INIT_MISMATCH => 408,
  TYPE_CHECKER_ARITY_MISMATCH => 409,
  TYPE_CHECKER_FUNC_ARG_MISMATCH => 410,
  TYPE_CHECKER_CANNOT_INFER_TYPE => 411,
  TYPE_CHECKER_MISSING_TYPE_ANNOTATIONS => 412,
  TYPE_CHECKER_TYPE_MISMATCH => 413,
  TYPE_CHECKER_MUTABILITY_MISMATCH => 414,
  TYPE_CHECKER_TUPLE_ARITY_MISMATCH => 416,
  TYPE_CHECKER_INDEX_TYPE_MISMATCH => 417,
  TYPE_CHECKER_ASSIGN_TYPE_MISMATCH => 418,
  TYPE_CHECKER_RETURN_TYPE_MISMATCH => 419,
  TYPE_CHECKER_CONST_INIT_MISMATCH => 420,
  TYPE_CHECKER_ARRAY_REPEAT_NOT_A_NUMBER => 421,
  TYPE_CHECKER_TY_CANT_BE_DEREFERENCED => 422,
  TYPE_CHECKER_NOT_ON_NUMERIC => 423,
  TYPE_CHECKER_STRUCT_PAT_NOT_ALL_FIELDS => 424,
  TYPE_CHECKER_LOCAL_PATTERN_IS_REFUTABLE => 425,
  TYPE_CHECKER_NO_VALUE_PASSED_FOR_PARAMETER => 426,
  TYPE_CHECKER_NO_FILED_ON_TY => 427,
  TYPE_CHECKER_CANNOT_CALL => 428,
  TYPE_CHECKER_NO_METHOD_FOR_TY => 429,
  TYPE_CHECKER_CANNOT_CONSTRUCT_ENUM_VARIANT_USING_CALL => 430,

  // Const eval (0500..0599)
  CONST_EVAL_INVALID_UNARY_OP => 500,
  CONST_EVAL_INVALID_BINARY_OP => 501,
  CONST_EVAL_DIVISION_BY_ZERO => 502,
  CONST_EVAL_SHIFT_OUT_OF_RANGE => 503,
  CONST_EVAL_UNSUPPORTED_EXPR => 504,
  CONST_EVAL_PATH_ISNT_CONST => 505,

  // Target/ABI codes (0600..0699)
  ABI_INVALID => 600,
  ABI_EXTERN_NO_BODY => 601,

  // Other (9000..9999)
  NO_MAIN_FUNCTION => 9000,
  MAIN_NO_GENERICS => 9001,
  MAIN_NO_PARAMS => 9002,
  MAIN_NOT_A_UNIT => 9003
}

#[cfg(test)]
mod tests {
  use super::*;
  use std::collections::HashSet;

  #[test]
  fn codes_are_unique_and_in_range() {
    let mut seen = HashSet::new();

    for &code in ALL_CODES {
      assert!((1..=9999).contains(&code.get()));
      assert!(seen.insert(code), "duplicate diagnostic code: {code}");

      let formatted = code.to_string();
      assert_eq!(formatted.len(), 4);
      assert!(formatted.chars().all(|c| c.is_ascii_digit()));
    }
  }
}
